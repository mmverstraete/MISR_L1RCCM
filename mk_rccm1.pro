FUNCTION mk_rccm1, $
   rccm_0, $
   misr_ptr, $
   radrd_ptr, $
   rccm_1, $
   n_miss_1, $
   VERBOSE = verbose, $
   DEBUG = debug, $
   EXCPT_COND = excpt_cond

   ;Sec-Doc
   ;  PURPOSE: This function flags pixels obscured by topography or
   ;  located on the edges of the MISR instrument swath within the
   ;  standard RCCM, provided through the input positional parameter
   ;  rccm_0.
   ;
   ;  ALGORITHM: This function uses the MISR L1B2 scaled radiance data
   ;  (with the RDQI attached) for the selected MODE, PATH, ORBIT and
   ;  BLOCK, accessed on the heap through the array of pointers radrd_ptr,
   ;  to flag obscured and ege pixels within the standard RCCM, available
   ;  as input array rccm_0.
   ;
   ;  SYNTAX: rc = mk_rccm1(rccm_0, misr_ptr, radrd_ptr, $
   ;  rccm_1, n_miss_1, VERBOSE = verbose, $
   ;  DEBUG = debug, EXCPT_COND = excpt_cond)
   ;
   ;  POSITIONAL PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   rccm_0 {BYTE array} [I]: An array containing the standard RCCM
   ;      product for the 9 camera files corresponding to the selected
   ;      MISR PATH, ORBIT and BLOCK.
   ;
   ;  *   misr_ptr {POINTER} [I]: The pointer to a STRING array containing
   ;      metadata on the MISR MODE, PATH, ORBIT and BLOCK of the next
   ;      pointer array.
   ;
   ;  *   radrd_ptr {POINTER array} [I]: The array of 36 pointers to the
   ;      data buffers containing the UINT L1B2 scaled radiance values
   ;      (with the RDQI attached), in the native order (DF to DA).
   ;
   ;  *   rccm_1 {BYTE array} [O]: An array containing the updated RCCM
   ;      product for the 9 camera files corresponding to the selected
   ;      MISR PATH, ORBIT and BLOCK, i.e., with non zero values for edge
   ;      and obscured pixels.
   ;
   ;  *   n_miss_1 {LONG array} [O]: An array reporting how many missing
   ;      values (0B) remain in each of these 9 cloud masks.
   ;
   ;  KEYWORD PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   VERBOSE = verbose {INT} [I] (Default value: 0): Flag to enable
   ;      (> 0) or skip (0) reporting progress on the console: 1 only
   ;      reports exiting the routine; 2 reports entering and exiting the
   ;      routine, as well as key milestones; 3 reports entering and
   ;      exiting the routine, and provides detailed information on the
   ;      intermediary results.
   ;
   ;  *   DEBUG = debug {INT} [I] (Default value: 0): Flag to activate (1)
   ;      or skip (0) debugging tests.
   ;
   ;  *   EXCPT_COND = excpt_cond {STRING} [O] (Default value: ”):
   ;      Description of the exception condition if one has been
   ;      encountered, or a null string otherwise.
   ;
   ;  RETURNED VALUE TYPE: INT.
   ;
   ;  OUTCOME:
   ;
   ;  *   If no exception condition has been detected, this function
   ;      returns 0, and the output keyword parameter excpt_cond is set to
   ;      a null string, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided in the call. The output positional parameters rccm_1
   ;      and n_miss_1 contain the updated cloud masks and the number of
   ;      missing values in each of them, respectively. The meaning of
   ;      pixel values in rccm_1 is as follows:
   ;
   ;      -   0B: Missing.
   ;
   ;      -   1B: Cloud with high confidence.
   ;
   ;      -   2B: Cloud with low confidence.
   ;
   ;      -   3B: Clear with low confidence.
   ;
   ;      -   4B: Clear with high confidence.
   ;
   ;      -   253B: Obscured.
   ;
   ;      -   254B: Edge.
   ;
   ;      -   255B: Fill.
   ;
   ;  *   If an exception condition has been detected, this function
   ;      returns a non-zero error code, and the output keyword parameter
   ;      excpt_cond contains a message about the exception condition
   ;      encountered, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided. The output positional parameters rccm_1 and n_miss_1
   ;      may be inexistent, incomplete or incorrect.
   ;
   ;  EXCEPTION CONDITIONS:
   ;
   ;  *   Error 100: One or more positional parameter(s) are missing.
   ;
   ;  *   Error 110: The input positional parameter rccm_0 is invalid.
   ;
   ;  *   Error 120: The input positional parameter misr_ptr is not a
   ;      pointer array.
   ;
   ;  *   Error 130: The input positional parameter radrd_ptr is not a
   ;      pointer array.
   ;
   ;  DEPENDENCIES:
   ;
   ;  *   is_array.pro
   ;
   ;  *   is_numeric.pro
   ;
   ;  *   is_pointer.pro
   ;
   ;  *   set_misr_specs.pro
   ;
   ;  *   strstr.pro
   ;
   ;  REMARKS: None.
   ;
   ;  EXAMPLES:
   ;
   ;      [See the outcome(s) generated by fix_rccm.pro]
   ;
   ;  REFERENCES:
   ;
   ;  *   Mike Bull, Jason Matthews, Duncan McDonald, Alexander Menzies,
   ;      Catherine Moroney, Kevin Mueller, Susan Paradise, Mike
   ;      Smyth (2011) _MISR Data Products Specifications_, JPL D-13963,
   ;      Revision S, Section 6.7.6, p. 85 for the RCCM values and Section
   ;      9.4.4, p. 210 for the AGP values.
   ;
   ;  VERSIONING:
   ;
   ;  *   2018–08–08: Version 0.8 — Original routines to manipulate MISR
   ;      RCCM data products provided by Linda Hunt.
   ;
   ;  *   2018–12–23: Version 0.9 — Initial release: This function and
   ;      those it depends on supersede all previous routines dealing with
   ;      MISR RCCM data products.
   ;
   ;  *   2018–12–30: Version 1.0 — Initial public release.
   ;
   ;  *   2019–01–30: Version 1.1 — Systematic update of all routines to
   ;      implement stricter coding standards and improve documentation.
   ;
   ;  *   2019–02–02: Version 1.2 — Delete unused variable pob_str and use
   ;      the Radiance rather than the Radiance/RDQI field in L1B2 files.
   ;
   ;  *   2019–02–05: Version 1.3 — Reorganize the MISR RCCM functions.
   ;
   ;  *   2019–02–18: Version 2.00 — Implement new algorithm (multiple
   ;      scans of the input cloud mask) to minimize artifacts in the
   ;      filled areas.
   ;
   ;  *   2019–02–27: Version 2.01 — New improved algorithm, capable of
   ;      dealing with cases where most values are missing within a BLOCK,
   ;      as long as values are not missing in neighboring cameras, access
   ;      MISR L1B2 data through pointers to heap variables rather than by
   ;      reading data files, rename this function from mk_rccm_1 to
   ;      mk_rccm1, and update the documentation.
   ;
   ;  *   2019–03–28: Version 2.10 — Update the handling of the optional
   ;      input keyword parameter VERBOSE and generate the software
   ;      version consistent with the published documentation.
   ;Sec-Lic
   ;  INTELLECTUAL PROPERTY RIGHTS
   ;
   ;  *   Copyright (C) 2017-2019 Michel M. Verstraete.
   ;
   ;      Permission is hereby granted, free of charge, to any person
   ;      obtaining a copy of this software and associated documentation
   ;      files (the “Software”), to deal in the Software without
   ;      restriction, including without limitation the rights to use,
   ;      copy, modify, merge, publish, distribute, sublicense, and/or
   ;      sell copies of the Software, and to permit persons to whom the
   ;      Software is furnished to do so, subject to the following three
   ;      conditions:
   ;
   ;      1. The above copyright notice and this permission notice shall
   ;      be included in its entirety in all copies or substantial
   ;      portions of the Software.
   ;
   ;      2. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY
   ;      KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   ;      WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
   ;      AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   ;      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   ;      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   ;      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   ;      OTHER DEALINGS IN THE SOFTWARE.
   ;
   ;      See: https://opensource.org/licenses/MIT.
   ;
   ;      3. The current version of this Software is freely available from
   ;
   ;      https://github.com/mmverstraete.
   ;
   ;  *   Feedback
   ;
   ;      Please send comments and suggestions to the author at
   ;      MMVerstraete@gmail.com
   ;Sec-Cod

   COMPILE_OPT idl2, HIDDEN

   ;  Get the name of this routine:
   info = SCOPE_TRACEBACK(/STRUCTURE)
   rout_name = info[N_ELEMENTS(info) - 1].ROUTINE

   ;  Initialize the default return code:
   return_code = 0

   ;  Set the default values of flags and essential output keyword parameters:
   IF (KEYWORD_SET(verbose)) THEN BEGIN
      IF (is_numeric(verbose)) THEN verbose = FIX(verbose) ELSE verbose = 0
      IF (verbose LT 0) THEN verbose = 0
      IF (verbose GT 3) THEN verbose = 3
   ENDIF ELSE verbose = 0
   IF (KEYWORD_SET(debug)) THEN debug = 1 ELSE debug = 0
   excpt_cond = ''

   IF (verbose GT 1) THEN PRINT, 'Entering ' + rout_name + '.'

   IF (debug) THEN BEGIN

   ;  Return to the calling routine with an error message if one or more
   ;  positional parameters are missing:
      n_reqs = 5
      IF (N_PARAMS() NE n_reqs) THEN BEGIN
         error_code = 100
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Routine must be called with ' + strstr(n_reqs) + $
            ' positional parameter(s): rccm_0, misr_ptr, radrd_ptr, ' + $
            'rccm_1, n_miss_1.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'rccm_0' is not a properly dimensioned BYTE array:
      sz = SIZE(rccm_0)
      IF ((sz[0] NE 3) OR $
         (sz[1] NE 9) OR $
         (sz[2] NE 512) OR $
         (sz[3] NE 128) OR $
         (sz[4] NE 1)) THEN BEGIN
         error_code = 110
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Positional parameter rccm_0 is invalid.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'misr_ptr' is not a pointer:
      IF (is_pointer(misr_ptr) NE 1) THEN BEGIN
         error_code = 120
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter misr_ptr is not a pointer.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'radrd_ptr' is not a pointer array:
      IF ((is_pointer(radrd_ptr) NE 1) OR (is_array(radrd_ptr) NE 1)) THEN BEGIN
         error_code = 130
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter radrd_ptr is not a ' + $
            'pointer array.'
         RETURN, error_code
      ENDIF
   ENDIF

   ;  Set the MISR specifications:
   misr_specs = set_misr_specs()
   n_cams = misr_specs.NCameras
   misr_cams = misr_specs.CameraNames

   ;  Retrieve the MISR Mode, Path, Orbit, Block and Version identifiers:
   temp = *misr_ptr
   misr_mode = temp[0]
   misr_path_str = temp[1]
   misr_orbit_str = temp[2]
   misr_block_str = temp[3]
   misr_version = temp[4]
   mpob_str = misr_mode + '-' + misr_path_str + '-' + $
      misr_orbit_str + '-' + misr_block_str

   ;  Define and initialize rccm_1 with rccm_0:
   rccm_1 = rccm_0
   n_miss_1 = LONARR(n_cams)

   ;  Loop over the 9 camera files:
   FOR cam = 0, n_cams - 1 DO BEGIN

   ;  Retrieve the 4 spectral bands for the current camera:
      blue = *radrd_ptr[cam, 0]
      IF (misr_cams[cam] EQ 'AN') THEN blue = hr2lr(blue)
      green = *radrd_ptr[cam, 1]
      IF (misr_cams[cam] EQ 'AN') THEN green = hr2lr(green)
      red = *radrd_ptr[cam, 2]
      red = hr2lr(red)
      nir = *radrd_ptr[cam, 3]
      IF (misr_cams[cam] EQ 'AN') THEN nir = hr2lr(nir)

   ;  Generate a temporary 2D cloud mask for the current camera:
      cld_msk = REFORM(rccm_0[cam, *, *])

   ;  Identify and count the non-retrieved pixels (value 0B):
      idx = WHERE(cld_msk EQ 0B, count)
      FOR i = 0, count - 1 DO BEGIN

   ;  Replace those that correspond to edge (65515) pixels by a flag value:
         IF ((blue[idx[i]] EQ 65515) OR $
            (green[idx[i]] EQ 65515) OR $
            (red[idx[i]] EQ 65515) OR $
            (nir[idx[i]] EQ 65515)) THEN BEGIN
            cld_msk[idx[i]] = 254B
         ENDIF

   ;  Replace those that correspond to obscured (65511) pixels by a flag value:
         IF ((blue[idx[i]] EQ 65511) OR $
            (green[idx[i]] EQ 65511) OR $
            (red[idx[i]] EQ 65511) OR $
            (nir[idx[i]] EQ 65511)) THEN BEGIN
            cld_msk[idx[i]] = 253B
         ENDIF
      ENDFOR

   ;  Copy this temporary cloud mask into rccm_1 and count the missing pixels:
      rccm_1[cam, *, *] = cld_msk
      idx = WHERE(cld_msk EQ 0B, cnt)
      n_miss_1[cam] = cnt

      IF (verbose GT 1) THEN BEGIN
         PRINT, 'rccm_1[' + misr_cams[cam] + '] contains ' + $
            strstr(cnt) + ' missing pixels.'
      ENDIF
   ENDFOR

   IF (verbose GT 0) THEN PRINT, 'Exiting ' + rout_name + '.'

   RETURN, return_code

END
